# 性能优化 开放题目
## 页面加载性能优化
  - 资源要小
    - 删除冗余代码
      - treeshaking
      - 压缩插件 删除无用代码 & 压缩代码
        - Webpack 配置（Terser）处理 js
        - Webpack 配置 css-minimizer-webpack-plugin PurgeCSS 处理 css
    - 按需加载
      - 路由 | 代码 按需加载 使用 import 动态导入实现
      - 组件按需加载 使用 React.lazy 和 import 动态导入实现
      - 图片按需加载 先置空占位 出现在视口时在加载图片
      - 数据按需加载 分页请求 按需请求 减少不必要的数据传输
    - 代码拆分
      - splitChunks 配置 Webpack 配置 细粒度拆分代码
      - 第三方库单独拆分 最大化利用缓存
    - 压缩
      - 代码层面压缩 Terser 插件
      - 网络传输层面压缩 gzip 压缩 brotli 压缩
        - 构建阶段产出 gz 压缩包 减少服务器压力
        - nginx 配置 gzip on 开启压缩
    - 图片体积优化
      - 合适的图片格式 现代格式的图片如 WebP 格式 体积更小
      - 合适的图片质量与尺寸 不要过大的图片 不同分辨率下使用不同图片
      - 图片懒加载 图片先占位 出现在视口时加载图片
      - CDN 加速 图片等静态资源使用 CDN 加速
      - image-webpack-loader 插件 压缩图片
      - 图像精灵 合并多张图片为一张图片 减少请求数
  - 缓存资源
    - 浏览器缓存 通过HTTP头部控制，如 Cache-Control、ETag、Last-Modified
    - DNS缓存 本地设备（如浏览器、操作系统、路由器等）中缓存DNS解析结果
    - CDN缓存 提高了静态资源加载的速度，并减轻了源服务器的压力。
    - 本地存储缓存 本地存储（如localStorage、sessionStorage、IndexedDB等）中缓存数据。
    - 构建阶段 利用版本控制和哈希值控制缓存
  - 请求要快
    - CDN 优化
    - 使用高版本的 http 协议 如 http2
    - 预加载和预链接
      - 预加载 <link rel="preload" href="image.png">
      - 预取 <link rel="prefetch" href="image.png">
      - 预连接 <link rel="preconnect" href="https://example.com">
        - 提前建立到第三方服务器的连接，包括 DNS 解析、TCP 握手和 TLS 连接，从而减少请求的延迟。
  
## 页面渲染性能优化
- SSR 渲染
  - 提高 SEO（搜索引擎优化）
  - 提高首屏渲染速度
- JS 优化
  - 代码优化
    - 避免使用全局变量 减少全局变量污染 会增加变量查找的时间
    - 缓存计算结果 避免不必要的计算 
    - Web Worker 进行异步计算 避免阻塞主线程
    - 使用事件委托，将事件绑定在父元素上
    - 避免数组、对象的深拷贝
  - 渲染优化
    - 避免重排和重绘
      - 一是修改 DOM 树的结构，移动增删等
      - 二是修改dom元素的几何属性，宽高之类的
      - 三是获取offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight这样的样式也会触发重排重绘
      - 缓存位置的值如：offsetTop，不要老访问
      - 使用 DocumentFragment 进行批量 DOM 操作，减少回流次数。
      - 避免逐个修改样式，而是使用 classList 统一修改。
    - 使用 Virtual DOM
  - 加载优化
    - 延迟加载 JavaScript, JavaScript 会阻塞 HTML 解析。应当使用 async 或 defer 加载脚本
  - 内存管理
    - 避免内存泄漏
      - 及时清除定时器
      - 避免 DOM 引用未释放
## React 性能优化
- 避免不必要的组件渲染
  - React.memo PureComponent
  - shouldComponentUpdate
  - useCallback 和 useMemo 主要用于缓存不变的函数和计算结果
- 合理使用useEffect，避免不必要的副作用
  - 依赖数组 配置不当会导致 副作用重复执行 副作用未更新 或者 性能问题
- 渲染列表优化
  - 使用 key 提高列表渲染性能
- 代码分割 & 资源优化
  - 使用 React.lazy 和 Suspense 进行懒加载
- 使用 Immutable 不可变数据
  - 降低数据可变性带来的复杂度
  - React 依赖 shouldComponentUpdate、React.memo 或 PureComponent 进行性能优化，但如果数据是可变的，React 无法正确判断是否需要重新渲染。
  - 避免并发问题，提高可预测性
    - React 18 引入了 并发模式（Concurrent Mode） ，可能会在不同的渲染阶段修改 state。
    - Immutable 数据保证数据只读，避免了 race condition（竞态条件）导致的错误。
## 开发阶段的优化
- 打包耗时
  - 利用多线程并行编译  Happypack 或 thread-loader
  - 拆分模块，减少重复编译 DLLPlugin
  - 缓存编译结果，加快增量构建 cache
    - babel-loader 缓存：减少 Babel 转译的重复计算。
    - terser-webpack-plugin 缓存：加速代码压缩过程。
    - 持久化缓存（cache: { type: 'filesystem' }）：将缓存存储到磁盘，加快二次构建速度。
  - 优化项目构建逻辑 通过调整项目结构，使打包过程只针对改动的部分代码进行增量编译，减少整体构建的工作量，从而有效降低编译时间。
    - webpack --watch 监听文件变更：仅编译改动的文件，提高热更新速度。
    - Hot Module Replacement (HMR) 热更新：仅更新变更部分，避免整个应用重新加载。
  - externals 提取项目依赖
## 前端性能监控
  - 前端性能监控量化 是指使用可量化的指标（如页面加载时间、交互响应速度、资源大小等）来评估网页或应用的性能，并通过监测这些指标的数据趋势，找出可能的性能瓶颈。
    - 页面加载性能（首屏渲染时间、白屏时间、资源加载速度）
    - 交互响应性能（用户操作的延迟、动画流畅度）
    - 代码执行性能（JavaScript 运行速度、计算密集型任务优化）
    - 网络请求优化（HTTP 请求数、请求大小、CDN 加速）
    - 错误和异常监控（JS 报错、网络请求失败）
  - 页面加载性能指标
    - TTFB（Time to First Byte）从用户发起请求到服务器返回第一字节的时间 🔥🔥🔥
    - FCP（First Contentful Paint）页面首次渲染内容出现的时间 🔥🔥
    - LCP（Largest Contentful Paint）加载最大可视内容（如大图片或大段文本）的时间 🔥🔥🔥
    - TTI（Time to Interactive）页面可以交互的时间 🔥🔥🔥
    - DOMContentLoaded（DCL）DOM 解析完成的时间 🔥
    - Load Time页面所有资源加载完成的时间 🔥
    - Performance API 监控 LCP
  - 交互体验性能指标
    - FID（First Input Delay）用户首次交互（点击、输入等）与浏览器响应之间的延迟 🔥🔥🔥
    - CLS（Cumulative Layout Shift）页面布局的视觉稳定性 🔥🔥
    - FPS（Frames Per Second）页面帧率，影响动画流畅度 🔥🔥
    - TBT（Total Blocking Time）JavaScript 阻塞主线程的时间 🔥🔥🔥
  - 如何进行前端性能监测?
    - Chrome DevTools
    - Lighthouse
    - Performance API
    - 第三方监控平台
      - Sentry