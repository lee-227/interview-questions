## Number

### 用科学记数法表示数
```js
var c = 156e4;
var d = 325e-3;

console.log(c, typeof(c));  // 1560000 "number"
console.log(d, typeof(d));  // 0.325 "number"
```

### 浮点数运算不精确
```js
0.55 * 100 // 55.00000000000001
0.1 + 0.2 //  0.30000000000004
```
- 计算机底层只有0 和 1， 所以所有的运算最后实际上都是二进制运算。十进制整数利用辗转相除的方法可以准确地转换为二进制数，但浮点数不能
- IEEE二进位浮点数算术标准 这个标准是JS的浮点数的实现标准 他规定 第一位是符号位 中间11位是指数位 最后52位代表尾数位
- 浮点数转换为二进制 =》 **整数部分采用除2取余，小数部分采用乘2取整**
```
0.1 转换为二进制：

0.1 * 2 -> 0.2 -> 小数位 0.2 -> 整数位 0
0.2 * 2 -> 0.4 -> 小数位 0.4 -> 整数位 0
0.4 * 2 -> 0.8 -> 小数位 0.8 -> 整数位 0
0.8 * 2 -> 1.6 -> 小数位 0.6 -> 整数位 1
0.6 * 2 -> 1.2 -> 小数位 0.2 -> 整数位 1
0.2 * 2 -> 0.4 -> 小数位 0.4 -> 整数位 0  
....
无限循环 -> 0.1 -> 0.000110011001100...
最终我们只能得到和的近似值（按照IEEE 754标准保留 52位，按 0舍1入 来取值）
```
- JS浮点数精度的缺失实际上是因为浮点数的小数部分无法用二进制很精准的转换出来，而以近似值来进行运算的话，肯定就存在精度的问题

### 怎么处理
- 浮点数的情况下会丢失精度，那我们所有运算的时候都**先将浮点数转换为整数，等计算完之后，再按比例转换会浮点数**，这样就避免了再二进制十进制转换的时候计算机的精度问题。
- 浮点数相乘时也会丢失经度，所以不能通过乘法将他转成整数。
```js
const add = (n1, n2) => {
    let pow = Math.max(n1.toString().split(".")[1].length, n2.toString().split(".")[1].length)
    let base = Math.pow(10, pow)
    n1 = n1.toString().split(".")[1]
    while(pow > n1.length){
      n1 += '0'
    }
    n2 = n2.toString().split(".")[1]
    while(pow > n2.length){
      n2 += '0'
    }
    // +  (Number(n1) + Number(n2)) / (base)
    // -  (Number(n1) - Number(n2)) / (base)
    // *  (Number(n1) * Number(n2)) / (base*base)
    // /  (Number(n1) / Number(n2))
    return (Number(n1) + Number(n2)) / (base)
}
```